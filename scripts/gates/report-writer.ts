#!/usr/bin/env ts-node
/**
 * Security Report Writer
 *
 * Generates human-readable Markdown summary reports and machine-parseable
 * JSON outputs from normalized security findings.
 *
 * Usage:
 *   ts-node report-writer.ts --input results.json --output summary.md
 */

import * as fs from 'fs';
import * as path from 'path';
import { NormalizedFinding } from './gate-evaluator';

interface ReportInput {
  findings: NormalizedFinding[];
  metadata: {
    timestamp: string;
    repository: string;
    branch: string;
    commit: string;
    triggeredBy: string;
  };
}

interface FindingsByTool {
  [tool: string]: NormalizedFinding[];
}

interface FindingsBySeverity {
  critical: NormalizedFinding[];
  high: NormalizedFinding[];
  medium: NormalizedFinding[];
  low: NormalizedFinding[];
  info: NormalizedFinding[];
}

class ReportWriter {
  private findings: NormalizedFinding[];
  private metadata: ReportInput['metadata'];

  constructor(input: ReportInput) {
    this.findings = input.findings;
    this.metadata = input.metadata;
  }

  /**
   * Generate a comprehensive Markdown summary report
   */
  generateMarkdown(): string {
    const lines: string[] = [];

    // Header
    lines.push('# üîê DevSecOps Security Scan Report\n');
    lines.push(`**Generated:** ${this.metadata.timestamp}`);
    lines.push(`**Repository:** ${this.metadata.repository}`);
    lines.push(`**Branch:** ${this.metadata.branch}`);
    lines.push(`**Commit:** ${this.metadata.commit}`);
    lines.push(`**Triggered by:** ${this.metadata.triggeredBy}\n`);
    lines.push('---\n');

    // Executive Summary
    lines.push('## üìä Executive Summary\n');
    const bySeverity = this.groupBySeverity();
    const byTool = this.groupByTool();

    const totalFindings = this.findings.length;
    const criticalCount = bySeverity.critical.length;
    const highCount = bySeverity.high.length;
    const mediumCount = bySeverity.medium.length;
    const lowCount = bySeverity.low.length;

    const status = criticalCount === 0 && highCount === 0 ? '‚úÖ PASS' : '‚ùå FAIL';
    const statusEmoji = criticalCount > 0 ? 'üö®' : highCount > 0 ? '‚ö†Ô∏è' : '‚úÖ';

    lines.push(`**Status:** ${status} ${statusEmoji}\n`);
    lines.push(`**Total Findings:** ${totalFindings}\n`);

    lines.push('| Severity | Count |');
    lines.push('|----------|-------|');
    lines.push(`| üî¥ Critical | ${criticalCount} |`);
    lines.push(`| üü† High | ${highCount} |`);
    lines.push(`| üü° Medium | ${mediumCount} |`);
    lines.push(`| üîµ Low | ${lowCount} |`);
    lines.push('');

    // Findings by Tool
    lines.push('## üõ†Ô∏è Findings by Security Tool\n');
    lines.push('| Tool | Findings | Critical | High | Medium | Low |');
    lines.push('|------|----------|----------|------|--------|-----|');

    for (const [tool, findings] of Object.entries(byTool)) {
      const toolSeverity = this.countSeverities(findings);
      lines.push(
        `| ${tool} | ${findings.length} | ${toolSeverity.critical} | ${toolSeverity.high} | ${toolSeverity.medium} | ${toolSeverity.low} |`
      );
    }
    lines.push('');

    // Critical Findings Detail
    if (criticalCount > 0) {
      lines.push('## üö® Critical Findings (Immediate Action Required)\n');
      this.appendFindingsTable(lines, bySeverity.critical);
    }

    // High Findings Detail
    if (highCount > 0) {
      lines.push('## ‚ö†Ô∏è High Severity Findings\n');
      this.appendFindingsTable(lines, bySeverity.high);
    }

    // Medium Findings Summary
    if (mediumCount > 0) {
      lines.push('## üü° Medium Severity Findings\n');
      lines.push(`<details>`);
      lines.push(`<summary>View ${mediumCount} medium severity findings</summary>\n`);
      this.appendFindingsTable(lines, bySeverity.medium);
      lines.push(`</details>\n`);
    }

    // Low Findings Summary
    if (lowCount > 0) {
      lines.push('## üîµ Low Severity Findings\n');
      lines.push(`<details>`);
      lines.push(`<summary>View ${lowCount} low severity findings</summary>\n`);
      this.appendFindingsTable(lines, bySeverity.low);
      lines.push(`</details>\n`);
    }

    // Recommendations
    lines.push('## üí° Recommendations\n');
    if (criticalCount > 0) {
      lines.push('- **CRITICAL:** Address all critical findings immediately before deployment');
    }
    if (highCount > 0) {
      lines.push('- **HIGH:** Create remediation tickets for all high severity findings');
    }
    if (mediumCount > 5) {
      lines.push('- **MEDIUM:** Prioritize medium findings in next sprint');
    }
    if (totalFindings === 0) {
      lines.push('- ‚úÖ No security findings detected. Great work!');
    }
    lines.push('');

    // Footer
    lines.push('---');
    lines.push('*Generated by DevSecOps Security Gates*');
    lines.push('*For more details, check the SARIF reports in GitHub Security tab*');

    return lines.join('\n');
  }

  /**
   * Generate JSON output with all findings
   */
  generateJson(): string {
    const output = {
      metadata: this.metadata,
      summary: {
        total: this.findings.length,
        bySeverity: this.countSeverities(this.findings),
        byTool: Object.fromEntries(
          Object.entries(this.groupByTool()).map(([tool, findings]) => [
            tool,
            findings.length,
          ])
        ),
      },
      findings: this.findings,
    };

    return JSON.stringify(output, null, 2);
  }

  /**
   * Append findings table to markdown lines
   */
  private appendFindingsTable(lines: string[], findings: NormalizedFinding[]): void {
    lines.push('| Tool | Rule ID | Title | File | Line |');
    lines.push('|------|---------|-------|------|------|');

    for (const finding of findings) {
      const title = this.truncate(finding.title, 60);
      const file = this.truncate(finding.file, 40);
      const line = finding.line || '-';
      lines.push(`| ${finding.tool} | \`${finding.ruleId}\` | ${title} | \`${file}\` | ${line} |`);
    }
    lines.push('');
  }

  /**
   * Group findings by severity
   */
  private groupBySeverity(): FindingsBySeverity {
    return this.findings.reduce(
      (acc, finding) => {
        acc[finding.severity].push(finding);
        return acc;
      },
      { critical: [], high: [], medium: [], low: [], info: [] } as FindingsBySeverity
    );
  }

  /**
   * Group findings by tool
   */
  private groupByTool(): FindingsByTool {
    return this.findings.reduce((acc, finding) => {
      if (!acc[finding.tool]) {
        acc[finding.tool] = [];
      }
      acc[finding.tool].push(finding);
      return acc;
    }, {} as FindingsByTool);
  }

  /**
   * Count findings by severity
   */
  private countSeverities(findings: NormalizedFinding[]) {
    return findings.reduce(
      (acc, f) => {
        acc[f.severity]++;
        return acc;
      },
      { critical: 0, high: 0, medium: 0, low: 0, info: 0 }
    );
  }

  /**
   * Truncate string to max length
   */
  private truncate(str: string, maxLength: number): string {
    return str.length > maxLength ? str.substring(0, maxLength - 3) + '...' : str;
  }
}

// ============================================================================
// Main Execution
// ============================================================================

function main() {
  const args = process.argv.slice(2);
  const inputPath = args.find(a => a.startsWith('--input='))?.split('=')[1];
  const outputPath = args.find(a => a.startsWith('--output='))?.split('=')[1];

  if (!inputPath || !outputPath) {
    console.error('Usage: ts-node report-writer.ts --input=results.json --output=summary.md');
    process.exit(1);
  }

  try {
    // Load input
    const inputData: ReportInput = JSON.parse(fs.readFileSync(inputPath, 'utf-8'));

    // Generate reports
    const writer = new ReportWriter(inputData);

    if (outputPath.endsWith('.md')) {
      const markdown = writer.generateMarkdown();
      fs.writeFileSync(outputPath, markdown);
      console.log(`‚úÖ Markdown report written to: ${outputPath}`);
    } else if (outputPath.endsWith('.json')) {
      const json = writer.generateJson();
      fs.writeFileSync(outputPath, json);
      console.log(`‚úÖ JSON report written to: ${outputPath}`);
    } else {
      console.error('Output file must be .md or .json');
      process.exit(1);
    }
  } catch (error) {
    console.error('‚ùå Failed to generate report:', error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { ReportWriter, ReportInput };
